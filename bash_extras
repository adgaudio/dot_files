#####
# ENV VARS
#####
export CDPATH="~:$CDPATH"
export EDITOR=vim
export HISTFILESIZE=10000
export HISTSIZE=5000
export PATH=~/bbin:~/bin:$PATH
export PYTHONSTARTUP=~/.pythonrc.py
export PYTHONPATH=.:$HOME/bin:$HOME:$PYTHONPATH

# Cuda ENV
export PATH=$PATH:/usr/local/cuda/bin
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64:/usr/local/cuda/lib
#####
# SHELL PROMPT
#####

# COLORS!!!
blue="\[\033[1;34m\]"
cyan="\[\033[2;36m\]"
cyan_bold="\[\033[1;36m\]"
gray="\[\033[0;37m\]"
green="\[\033[0;32m\]"
green_bold="\[\033[1;32m\]"
orange="\[\033[0;93m\]"  # not on all terminals
purple="\[\033[0;35m\]"
red="\[\033[0;31m\]"
white="\[\033[0m\]"
yellow="\[\033[0;33m\]"

date_="\d \A"
host="\h"
pwd="\w"

# am I currently logged in as my default user?
ME=(me alex alexgaudio)
isme="$(grep " $(whoami) " <(echo ${ME[@]:0}) >/dev/null ; echo $?)"
imposter="\$(if [[ "$isme" -ne "0" ]]; then echo \"${purple}($(whoami)) | \"; fi )"


available_virtualenvs="$(workon|paste -sd '|')"
user_workon=false

function reactivate() {
  echo "--> auto-execution of cmd, 'workon {env}' re-enabled"
  user_workon=false
}

workon_virtualenv() {
  # Automatically call "workon some_virtualenv" if current directory shares the same name as one of your virtualenvs
  # and deactivate virtualenv if current directory is $HOME
  #
  # If user explicitly calls workon or deactivate, stop auto-selecting virtual environments.
  # The "reactivate" will let this function start auto-selecting virtual environments again.
  #
  # Assumes that two global variables are defined:
  #  - user_workon=true|false
  #  - current_command is the most recent line entered into the shell

  # Figure out what to do if this function is currently disabled, and if it is being turned off
  local last_command="$(fc -ln -1)"
  if [[ "$last_command" =~ mkvirtualenv\ \s+ ]] ; then
    available_virtualenvs="$(workon|paste -sd '|')"
  fi
  if [[ "$user_workon" = "false" && ! "$current_command"  =~ \ reactivate([ \|\;]|$) ]] ; then
    # does last command include "workon XXX" or "deactivate"?
    [[ "$current_command" =~ workon\ (${available_virtualenvs})([ \|\;]|$) ]] && matches_workon=true || matches_workon=false
    [[ "$current_command" =~ deactivate([ \|\;]|$) ]] && matches_deactivate=true || matches_deactivate=false
    if [[ "$matches_workon" = "true"  || "$matches_deactivate" = "true" ]] ; then
      echo "--> automatic virtualenv selection disabled. Typing 'reactivate' will re-enable this feature"
      user_workon=true
      return
    fi
  elif [ "$user_workon" = "true" ] ; then
    return
  else
    echo "unrecognized value for \$user_workon: \"$user_workon\"!"
  fi

  # Determine whether to change virtualenv
  current_dir="${PWD##*/}"
  venv="${VIRTUAL_ENV##*/}"
  if [[ "$current_dir" =~ (${available_virtualenvs}) && "$venv" != "$current_dir" ]] ; then
    if [[ "$venv" ]] ; then
       deactivate && echo "--> deactivate ${venv}"
    fi
     workon $current_dir 2>&1 && echo "--> workon $current_dir"
     basedir_for_virtualenv="$PWD"
  elif [[ "$venv" && "$PWD" != "$basedir_for_virtualenv"* ]] ; then
    # if the directory you've declared workon in is not a parent of the current directory, deactivate
    echo '--> deactivate'
    deactivate
  fi
}

function _my_ps1() {

  # change colors based on success of last command
  local last_rv=$?
  if [ $last_rv = 0 ] ; then
    stoplight_color="${green}"
  else
    stoplight_color="${red}"
  fi

  local git_status="`git status -sb 2>&1`"
  if [[ "$git_status" =~ .*[^\ ]MM\  ]] ; then
    #MM
    git_status_color=${red}
  elif [[ "$git_status" =~ .*[^\ ]M\ \  ]] ; then
    git_status_color=${orange}
    #M 
  elif [[ "$git_status" =~ .*[^\ ]\ M\  ]] ; then
    git_status_color=${yellow}
     #M
  elif [[ "$git_status" =~ .*[^\ ]\?\?\  ]] ; then
    #??
    git_status_color=${green_bold}
  else
    #clean
    git_status_color=${green}
  fi
  # Set git branch
  [[ "$git_status" =~ \##\ ([A-Za-z0-9_]+) ]] && git_branch=${BASH_REMATCH[1]} || git_branch="no git"

  if [[ "$VIRTUAL_ENV" ]] ; then
    echo -n "\n${cyan_bold}(${VIRTUAL_ENV##*/})"
  fi
  echo -n "\n${imposter}${cyan}${date_} | ${gray}${pwd} | ${git_status_color}${git_branch} | ${gray}`hostname`"
  #echo -n "${white} | $(history |tail -n 1 | cut -d ' ' -f 3-20 | realiaser)"
  echo -n "\n${stoplight_color} \$ ${white}"
}

function _prompt_command() {
    # execute hooks
    workon_virtualenv
    PS1="`_my_ps1`"
}

preexec () { # executes before (and twice after?!) the command-line is run
  :; echo 'running preexec this_command' $this_command ; }
preexec_invoke_exec () {
  # thank you to:
  # http://superuser.com/questions/175799/does-bash-have-a-hook-that-is-run-before-executing-a-command
    [ -n "$COMP_LINE" ] && return  # do nothing if completing
    [ "$BASH_COMMAND" = "$PROMPT_COMMAND" ] && return # don't cause a preexec for $PROMPT_COMMAND
    current_command=`history 1 | sed -e "s/^[ ]*[0-9]*[ ]*//g"`;
    #preexec "$current_command"
}
PROMPT_COMMAND="trap 'preexec_invoke_exec' DEBUG ; _prompt_command"


######
# Bash awesomeness
######

# Shell acts like vim
#set -o vi # check out inputrc for extra bindings and if necessary: #export INPUTRC=~/.inputrc
#
shopt -s autocd  #don't type cd to navigate directories
shopt -s cdable_vars # set the bash option so that no '$' is required when using the above facility
shopt -s cdspell #cd command will guess misspelled directories
shopt -s extglob #ability to use pattern matching like *(pattern1|pattern2) and ?(...) !(...) @(...)
shopt -s globstar # ** globs all files, sub-files and subdirectories
shopt -s lithist #multi-line commands are saved to history with newlines rather than semi-colons
shopt -s checkwinsize #update the values of LINES and COLUMNS after each cmd


# cd tricks from hayne.net/MacDev/Bash/aliases.bash
#EX:
#  $ save hi # saves hi=$PWD to a file ~/.dirs
#  $ sdirs # sources ~/.dirs
#  $ cd hi # note: 'shopt -s cdable_vars' is set above
alias sdirs='source ~/.dirs'
alias show='cat ~/.dirs'
function save ()
{
 sed --regexp-extended "/^$@$/d" ~/.dirs > ~/.dirs1; \mv ~/.dirs1 ~/.dirs; echo "$@"=\"`pwd`\" >> ~/.dirs; source ~/.dirs ; 
}

# stop XOFF and XON being sent from the keyboard via <C-s> and <C-q>
# but still allowing other software to send the commands.
# useful for vim-ipython plugin and anything that binds to <C-s>
stty ixoff -ixon
